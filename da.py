# -*- coding: utf-8 -*-
"""DA.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qtEMe7GhyG6y-1n-x7KGjZyO1p5TjAFG
"""

# Importing necessary libraries

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import plotly.express as px
import networkx as nx
import calendar
import plotly.graph_objects as go
from sklearn.model_selection import train_test_split
from imblearn.over_sampling import SMOTE
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import classification_report, accuracy_score, precision_recall_fscore_support

# Loading data

df = pd.read_csv('cyber-operations-incidents.csv')

# Overview of the dataset

print(df.head(), "\n\n")
print(df.info(), "\n\n")
print(df.describe(), "\n\n")
print(df.shape, "\n\n")
print(df.isna().sum(), "\n\n")
print(df.duplicated().sum())

# Data Cleaning

# Extracting year and month from date
df['Date'] = pd.to_datetime(df['Date'])
df['Year'] = df['Date'].dt.year
df['Month'] = df['Date'].dt.month
df.fillna('Unknown', inplace=True)
print(df.head(), "\n\n")
print(df.isna().sum())

# Creating two new columns Response_Type and Response_ref from Response using split
def custom_split(response):
    if 'Hack Back' in response:
        response_type = 'Hack Back'
        response_ref = response.split('Hack Back', 1)[-1].strip()
    elif 'Criminal charges' in response:
        response_type = 'Criminal charges'
        response_ref = response.split('Criminal charges', 1)[-1].strip()
    elif ' ' in response:
        response_type, response_ref = response.split(' ', 1)
    else:
        response_type = response
        response_ref = None
    return response_type, response_ref

#Applying the split function on Response
df[['Response_Type', 'Response_Ref']] = df['Response'].apply(custom_split).apply(pd.Series)

# Finding indices of rows where Victims and Sponsors are Unknown
indices_to_drop = df[((df['Victims'] == 'Unknown') & (df['Sponsor'] == 'Unknown'))].index

# Dropping those rows
df.drop(index=indices_to_drop, inplace=True)
indices_to_drop1 = df[((df['Sources_1'] == 'Unknown') & (df['Sources_2'] == 'Unknown') & (df['Sources_3'] == 'Unknown'))].index
df.drop(index=indices_to_drop1, inplace=True)
print(df.head())

# Exploratory Data Analysis

# Trend analysis
years = df.Year.copy()
years = years[years!='Unknown'].copy()
year_counts = years.value_counts().sort_index()

# Creating line chart using years
fig = px.line(x=year_counts.index, y=year_counts.values,
              title='Number of attacks per Year',
              labels={'x': 'Year', 'y': 'Number of Events'})
fig.update_layout(paper_bgcolor="#CCCCFF",
                  plot_bgcolor="#BDB5D5",
                  xaxis_tickangle=-45,
                  xaxis_title_font={'size': 14, "color": "#483248", "family": "Arial Black"},
                  yaxis_title_font={'size': 14, "color": "#483248", "family": "Arial Black"},
                  font=dict(color="#483248", family="Arial Black"),
                  title_font=dict(size=20, color="#483248", family="Arial Black"),
                  xaxis = dict(
                      tickfont = dict(size=12, color="#483248", family="Arial Black")
                      ),
                  yaxis = dict(
                      tickfont = dict(size=12, color="#483248", family="Arial Black")
                      ))
fig.update_traces(line_color="#483248")
fig.show()

# Seasonality
months = df.Month.copy()
months = months[months!='Unknown'].copy()
months = months.astype(int)
months = months.apply(lambda x: calendar.month_name[x] if 1 <= x <= 12 else 'Unknown') # Getting the month names
months_counts = months.value_counts()
months_order = list(calendar.month_name[1:])
months_counts = months_counts.reindex(months_order)

# Creating line chart using months
fig = px.line(x=months_counts.index, y=months_counts.values,
              title='Number of Attacks by month',
              labels={'x': 'Month', 'y': 'Number of Events by month'})
fig.update_layout(paper_bgcolor="#89CFF0",
                  plot_bgcolor="#ADD8E6",
                  xaxis_tickangle=-45,
                  xaxis_title_font={'size': 14, "color": "#191970", "family": "Arial Black"},
                  yaxis_title_font={'size': 14, "color": "#191970", "family": "Arial Black"},
                  font=dict(color="#191970", family="Arial Black"),
                  title_font=dict(size=20, color="#191970", family="Arial Black"),
                  xaxis = dict(
                      tickfont = dict(size=12, color="#191970", family="Arial Black")
                      ),
                  yaxis = dict(
                      tickfont = dict(size=12, color="#191970", family="Arial Black")
                      ))
fig.update_traces(line_color="#191970")
fig.show()

# Geospatial analysis

# Plotting attack origins and targets
# Splitting Sponsor column to get unique countries
df['Countries'] = df['Sponsor'].str.split(', ').apply(lambda x: [country.strip() for country in x])
all_countries = [country for sublist in df['Countries'] for country in sublist]
country_counts = pd.Series(all_countries).value_counts()

# Creating choropleth map for attacks sponsored by different countries
fig_map = px.choropleth(
    locations=country_counts.index,
    locationmode="country names",
    color=country_counts.values,
    color_continuous_scale="Viridis",
    title="Cyber Operations by Sponsor Country",
    labels={"color": "Number of Attacks"},
)
fig_map.update_geos(
    visible=False,
    showcountries=True,
    countrycolor="lightgray",
)
fig_map.show()
table_data = [
    go.Table(
        header=dict(values=["Country", "Number of Attacks"],
                    fill_color='paleturquoise',
                    align='left'),
        cells=dict(values=[country_counts.index, country_counts.values],
                   fill_color='lavender',
                   align='left'))
]
layout = go.Layout(
    geo=dict(
        showframe=False,
        showcoastlines=False,
        projection_type='equirectangular'
    ),
)
fig = go.Figure(data=[fig_map.data[0]] + table_data, layout=layout)

fig.show()

# Splitting Sector column to get unique sectors
df['Sectors'] = df['Category'].str.split(', ').apply(lambda x: [sector.strip() for sector in x])
all_sectors = [sector for sublist in df['Sectors'] for sector in sublist]
sector_counts = pd.Series(all_sectors).value_counts()

# Creating pie chart for number of attacks on each sector
fig_pie = px.pie(
    values=sector_counts.values,
    names=sector_counts.index,
    title='Number of Attacks by Sector',
    color_discrete_sequence=px.colors.qualitative.Pastel
)
fig_pie.update_layout(
    paper_bgcolor="#FAA0A0",
    font=dict(color="#4A0404", family="Arial Black"),
    title_font=dict(size=20, color="#4A0404", family="Arial Black")
    )
fig_pie.show()

# Creating bar chart for types of attacks
type_counts = df['Type'].value_counts()
type_counts = type_counts.sort_values(ascending=True)
fig_sponsor = px.bar(
    y=type_counts.index,
    x=type_counts.values,
    orientation='h',
    title='Types of Attacks',
    labels={'y': 'Type', 'x': 'Number of Attacks'},
    text=type_counts.values
)
fig_sponsor.update_layout(
    paper_bgcolor="#AFE1AF",
    plot_bgcolor="#90EE90",
    xaxis_title_font={'size': 14, "color": "#023020", "family": "Arial Black"},
    yaxis_title_font={'size': 14, "color": "#023020", "family": "Arial Black"},
    font=dict(color="#023020", family="Arial Black"),
    title_font=dict(size=20, color="#023020", family="Arial Black"),
    xaxis=dict(tickfont=dict(size=12, color="#023020", family="Arial Black")),
    yaxis=dict(tickfont=dict(size=12, color="#023020", family="Arial Black"))
)
fig_sponsor.update_traces(textposition='outside', marker_color='#023020')
fig_sponsor.show()

# Grouping data for finding affiliations networks for each sponsor
affiliation_network = df.groupby(['Affiliations', 'Sponsor']).size().unstack().fillna(0)

# Excluding unknown values
affiliation_network = affiliation_network.drop(index='Unknown', errors='ignore')
affiliation_network = affiliation_network.drop(columns=['Unknown'], errors='ignore')

# Getting top 10 sponsors and affiliations
top_sponsors = affiliation_network.sum().sort_values(ascending=False).head(10).index
top_affiliations = affiliation_network.sum(axis=1).sort_values(ascending=False).head(10).index
affiliation_network = affiliation_network.loc[top_affiliations, top_sponsors]

# Creating stacked bar chart for affiliations per sponsor
fig = go.Figure()
for affiliation in affiliation_network.index:
    fig.add_trace(go.Bar(
        name=affiliation,
        x=affiliation_network.columns,
        y=affiliation_network.loc[affiliation],
    ))
fig.update_layout(
    barmode='stack',
    title='Affiliation Networks by Sponsor',
    xaxis_title='Sponsor',
    yaxis_title='Count',
)
fig.show()

# Grouping data for finding sponsors for each attack type
sponsor_type = df.groupby(['Sponsor', 'Type']).size().unstack().fillna(0)

# Excluding unknown values
sponsor_type = sponsor_type.drop(index='Unknown', errors='ignore')
sponsor_type = sponsor_type.drop(columns=['Unknown'], errors='ignore')

# Getting top 10 sponsors and attack types
top_sponsors = sponsor_type.sum().sort_values(ascending=False).head(10).index
top_types = sponsor_type.sum(axis=1).sort_values(ascending=False).head(10).index
sponsor_type = sponsor_type.loc[top_types, top_sponsors]

# Creating stacked bar chart for sponsors per attack type
fig = go.Figure()
for spotype in sponsor_type.index:
    fig.add_trace(go.Bar(
        name=spotype,
        x=sponsor_type.columns,
        y=sponsor_type.loc[spotype],
    ))
fig.update_layout(
    barmode='stack',
    title='Attack types by Sponsor',
    xaxis_title='Type',
    yaxis_title='Count',
)
fig.show()

# Finding top 10 victims
victim_counts = df['Victims'].value_counts().nlargest(10)
victim_counts = victim_counts[victim_counts.index != 'Unknown']
victim_counts = victim_counts.nlargest(10)
victim_counts = victim_counts.sort_values(ascending=True)

# Creating bar chart for top 10 victims
fig_sponsor = px.bar(
    y=victim_counts.index,
    x=victim_counts.values,
    title='Top 10 Victims',
    labels={'y': 'Victim', 'x': 'Number of Attacks'},
    text=victim_counts.values
)
fig_sponsor.update_layout(
    paper_bgcolor="#C19A6B",
    plot_bgcolor="#C4A484",
    xaxis_title_font={'size': 14, "color": "#3d2b1f", "family": "Arial Black"},
    yaxis_title_font={'size': 14, "color": "#3d2b1f", "family": "Arial Black"},
    font=dict(color="#3d2b1f", family="Arial Black"),
    title_font=dict(size=20, color="#3d2b1f", family="Arial Black"),
    xaxis=dict(tickfont=dict(size=12, color="#3d2b1f", family="Arial Black")),
    yaxis=dict(tickfont=dict(size=12, color="#3d2b1f", family="Arial Black"))
)
fig_sponsor.update_traces(textposition='outside', marker_color='#3d2b1f')
fig_sponsor.show()

# Finding count of response types
print(df['Response_Type'].value_counts())

# Grouping data for finding victims response types
victim_response = df.groupby(['Victims', 'Response_Type']).size().unstack().fillna(0)

# Excluding unknown values
victim_response= victim_response.drop(index='Unknown', errors='ignore')
victim_response = victim_response.drop(columns=['Unknown'], errors='ignore')

# Getting top 10 victims and their response types
top_victims = victim_response.sum(axis=1).sort_values(ascending=False).head(10).index
top_responses = victim_response.sum().sort_values(ascending=False).head(10).index
victim_response = victim_response.loc[top_victims, top_responses]

# Creating stacked bar chart for count of victims per response type
fig = go.Figure()
for victres in victim_response.index:
    fig.add_trace(go.Bar(
        name=victres,
        x=victim_response.columns,
        y=victim_response.loc[victres],
    ))
fig.update_layout(
    barmode='stack',
    title='Response types by Victim',
    xaxis_title='Response types',
    yaxis_title='Count',
)
fig.show()



# Data Modelling

X = df[['Year', 'Month', 'Sponsor', 'Category']]  # Features

# Removing unknown years and months from the data
X = X[(X['Year'] != 'Unknown') & (X['Month'] != 'Unknown')].copy()
X.loc[:, 'Year'] = pd.to_numeric(X.loc[:, 'Year'])
X.loc[:, 'Month'] = pd.to_numeric(X.loc[:, 'Month'])
y = df.loc[X.index, 'Type']

# Converting year and month to numeric
X['Year'] = pd.to_numeric(X['Year'])
X['Month'] = pd.to_numeric(X['Month'])

# Encoding categorical variables
X = pd.get_dummies(X, drop_first=True)

# Plot for class imbalance
class_counts = y.value_counts()
plt.figure(figsize=(10, 6))
sns.countplot(x=y, order=class_counts.index, color='darkgreen')
plt.title('Class Imbalance')
plt.xlabel('Attack Type')
plt.ylabel('Count')
plt.xticks(rotation=45, ha='right')
plt.tight_layout()
plt.show()

# Performing oversampling for class imbalance
smote = SMOTE(random_state=42)
X_resampled, y_resampled = smote.fit_resample(X, y)

# Splitting data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X_resampled, y_resampled, test_size=0.3, random_state=42)

# Training a Random Forest Classifier
clf = RandomForestClassifier(n_estimators=100, random_state=42)
clf.fit(X_train, y_train)

# Making predictions
y_pred = clf.predict(X_test)

# Evaluating the model
print("Accuracy:", accuracy_score(y_test, y_pred))
print("Classification Report:\n", classification_report(y_test, y_pred, zero_division=0))

# Extracting precision, recall, and F1-score for each class
precision, recall, f1, _ = precision_recall_fscore_support(y_test, y_pred, zero_division=0)
class_labels = np.unique(y_test)

# Creatting three subplots
fig, axs = plt.subplots(3, 1, figsize=(10, 15))

# Precision plot
axs[0].plot(class_labels, precision, marker='o', linestyle='-', color='darkred')
axs[0].set_title('Precision per Class')
axs[0].set_xlabel('Class')
axs[0].set_ylabel('Precision')
axs[0].set_xticklabels(class_labels, rotation=45, ha='right')

# Recall plot
axs[1].plot(class_labels, recall, marker='o', linestyle='-', color='darkblue')
axs[1].set_title('Recall per Class')
axs[1].set_xlabel('Class')
axs[1].set_ylabel('Recall')
axs[1].set_xticklabels(class_labels, rotation=45, ha='right')

# F1-score plot
axs[2].plot(class_labels, f1, marker='o', linestyle='-', color='darkviolet')
axs[2].set_title('F1-score per Class')
axs[2].set_xlabel('Class')
axs[2].set_ylabel('F1-score')
axs[2].set_xticklabels(class_labels, rotation=45, ha='right')
plt.tight_layout()
plt.show()